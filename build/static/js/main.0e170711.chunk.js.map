{"version":3,"sources":["components/tetris-board.tsx","components/tetris.tsx","serviceWorker.ts","index.tsx"],"names":["TetrisBoard","props","rows","field","forEach","row","index","cols","map","column","className","key","push","level","score","gameOver","Tetris","handlePauseClick","setState","prev","isPaused","handleNewGameClick","y","boardHeight","x","boardWidth","xStart","Math","floor","parseInt","activeTileX","activeTileY","activeTile","tileRotate","tileCount","state","timerId","tiles","window","setInterval","handleBoardUpdate","this","clearInterval","command","xAdd","yAdd","rotateAdd","tile","rotate","xAddIsValid","i","newRotate","rotateIsValid","yAddIsValid","isLineComplete","col","random","onClick","React","Boolean","location","hostname","match","ReactDOM","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.0e170711.chunk.js","sourcesContent":["import * as React from 'react'\n\ntype TetrisBoardProps = {\n    field: any[],\n    gameOver: boolean,\n    score: number,\n    level: number,\n    rotate: number\n}\n\nconst TetrisBoard: React.FC<TetrisBoardProps> = (props) => {\n    // Create board rows\n    let rows: any[] = []\n  \n    props.field.forEach((row, index) => {\n      // Create board columns\n      const cols = row.map((column: any, index: number) => <div className={`col-${column}`} key={index} />)\n  \n      rows.push(<div className=\"tetris-board__row\" key={index}>{cols}</div>)\n    })\n\n    return (\n        <div className=\"tetris-board\">\n            {/* Game info */}\n            <div className=\"tetris-board__info\">\n            <p className=\"tetris-board__text\">Level: {props.level}</p>\n\n            <p className=\"tetris-board__text\">Score: {props.score}</p>\n\n            {props.gameOver && <p className=\"tetris-board__text\"><strong>Game Over</strong></p>}\n            </div>\n\n            {/* Game board */}\n            <div className=\"tetris-board__board\">{rows}</div>\n        </div>\n    )\n}\n\nexport default TetrisBoard\n","import * as React from 'react'\nimport TetrisBoard from './tetris-board'\n\ntype TetrisProps = {\n    boardWidth: any,\n    boardHeight: any\n}\n\ntype TetrisState = {\n    activeTileX: number,\n    activeTileY: number,\n    activeTile: number,\n    tileRotate: number,\n    score: number,\n    level: number,\n    tileCount: number,\n    gameOver: boolean,\n    isPaused: boolean,\n    field: any[],\n    timerId: any,\n    tiles: number[][][][]\n}\n\nclass Tetris extends React.Component<TetrisProps, TetrisState> {\n    constructor(props: any) {\n        super(props)\n\n        let field = []\n\n        for (let y = 0; y < props.boardHeight; y++) {\n            let row = []\n\n            for (let x = 0; x < props.boardWidth; x++) {\n                row.push(0)\n            }\n\n            field.push(row)\n        }\n\n        // Set starting column to center\n    let xStart = Math.floor(parseInt(props.boardWidth) / 2)\n\n    // Initialize state with starting conditions\n    this.state = {\n        activeTileX: xStart,\n        activeTileY: 1,\n        activeTile: 1,\n        tileRotate: 0,\n        score: 0,\n        level: 1,\n        tileCount: 0,\n        gameOver: false,\n        isPaused: false,\n        field: field,\n        timerId: null,\n        tiles: [\n            // 7 tiles\n            // Each tile can be rotated 4 times (x/y coordinates)\n            [\n                // The default square\n                [[0, 0], [0, 0], [0, 0], [0, 0]],\n                [[0, 0], [0, 0], [0, 0], [0, 0]],\n                [[0, 0], [0, 0], [0, 0], [0, 0]],\n                [[0, 0], [0, 0], [0, 0], [0, 0]]\n            ],\n            [\n                // The cube tile (block 2x2)\n                [[0, 0], [1, 0], [0, 1], [1, 1]],\n                [[0, 0], [1, 0], [0, 1], [1, 1]],\n                [[0, 0], [1, 0], [0, 1], [1, 1]],\n                [[0, 0], [1, 0], [0, 1], [1, 1]]\n            ],\n            [\n                // The I tile\n                [[0, -1], [0, 0], [0, 1], [0, 2]],\n                [[-1, 0], [0, 0], [1, 0], [2, 0]],\n                [[0, -1], [0, 0], [0, 1], [0, 2]],\n                [[-1, 0], [0, 0], [1, 0], [2, 0]]\n            ],\n            [\n                // The T tile\n                [[0, 0], [-1, 0], [1, 0], [0, -1]],\n                [[0, 0], [1, 0], [0, 1], [0, -1]],\n                [[0, 0], [-1, 0], [1, 0], [0, 1]],\n                [[0, 0], [-1, 0], [0, 1], [0, -1]]\n            ],\n            [\n                // The inverse L tile\n                [[0, 0], [-1, 0], [1, 0], [-1, -1]],\n                [[0, 0], [0, 1], [0, -1], [1, -1]],\n                [[0, 0], [1, 0], [-1, 0], [1, 1]],\n                [[0, 0], [0, 1], [0, -1], [-1, 1]]\n            ],\n            [\n                // The L tile\n                [[0, 0], [1, 0], [-1, 0], [1, -1]],\n                [[0, 0], [0, 1], [0, -1], [1, 1]],\n                [[0, 0], [1, 0], [-1, 0], [-1, 1]],\n                [[0, 0], [0, 1], [0, -1], [-1, -1]]\n            ],\n            [\n                // The Z tile\n                [[0, 0], [1, 0], [0, -1], [-1, -1]],\n                [[0, 0], [1, 0], [0, 1], [1, -1]],\n                [[0, 0], [1, 0], [0, -1], [-1, -1]],\n                [[0, 0], [1, 0], [0, 1], [1, -1]]\n            ],\n            [\n                // The inverse Z tile\n                [[0, 0], [-1, 0], [0, -1], [1, -1]],\n                [[0, 0], [0, -1], [1, 0], [1, 1]],\n                [[0, 0], [-1, 0], [0, -1], [1, -1]],\n                [[0, 0], [0, -1], [1, 0], [1, 1]]\n            ]\n        ]\n    }\n}\n\n/**\n   * @description Sets timer after component mounts\n   * Uses level (this.state.level) to determine the interval (game speed)\n   * and executes handleBoardUpdate() set to 'down' method during each interval\n   * @memberof Tetris\n   */\n  componentDidMount() {\n    let timerId\n\n    timerId = window.setInterval(\n      () => this.handleBoardUpdate('down'),\n      1000 - (this.state.level * 10 > 600 ? 600 : this.state.level * 10)\n    )\n\n    this.setState({\n      timerId: timerId\n    })\n  }\n\n  /**\n   * @description Resets the timer when component unmounts\n   * @memberof Tetris\n   */\n  componentWillUnmount() {\n    window.clearInterval(this.state.timerId)\n  }\n\n  /**\n   * @description Handles board updates\n   * @param {string} command\n   * @memberof Tetris\n   */\n  handleBoardUpdate(command: string) {\n    // Do nothing if game ends, or is paused\n    if (this.state.gameOver || this.state.isPaused) {\n      return\n    }\n\n    // Prepare variables for additions to x/y coordinates, current active tile and new rotation\n    let xAdd = 0\n    let yAdd = 0\n    let rotateAdd = 0\n    let tile = this.state.activeTile\n\n    // If tile should move to the left\n    // set xAdd to -1\n    if (command === 'left') {\n      xAdd = -1\n    }\n\n    // If tile should move to the right\n    // set xAdd to 1\n    if (command === 'right') {\n      xAdd = 1\n    }\n\n    // If tile should be rotated\n    // set rotateAdd to 1\n    if (command === 'rotate') {\n      rotateAdd = 1\n    }\n\n    // If tile should fall faster\n    // set yAdd to 1\n    if (command === 'down') {\n      yAdd = 1\n    }\n\n    // Get current x/y coordinates, active tile, rotate and all tiles\n    let field = this.state.field\n    let x = this.state.activeTileX\n    let y = this.state.activeTileY\n    let rotate = this.state.tileRotate\n\n    const tiles = this.state.tiles\n\n    // Remove actual tile from field to test for new insert position\n    field[y + tiles[tile][rotate][0][1]][x + tiles[tile][rotate][0][0]] = 0\n    field[y + tiles[tile][rotate][1][1]][x + tiles[tile][rotate][1][0]] = 0\n    field[y + tiles[tile][rotate][2][1]][x + tiles[tile][rotate][2][0]] = 0\n    field[y + tiles[tile][rotate][3][1]][x + tiles[tile][rotate][3][0]] = 0\n\n    // Test if the move can be executed on actual field\n    let xAddIsValid = true\n\n    // Test if tile should move horizontally\n    if (xAdd !== 0) {\n      for (let i = 0; i <= 3; i++) {\n        // Test if tile can be moved without getting outside the board\n        if (\n          x + xAdd + tiles[tile][rotate][i][0] >= 0\n          && x + xAdd + tiles[tile][rotate][i][0] < this.props.boardWidth\n        ) {\n          if (field[y + tiles[tile][rotate][i][1]][x + xAdd + tiles[tile][rotate][i][0]] !== 0) {\n            // Prevent the move\n            xAddIsValid = false\n          }\n        } else {\n          // Prevent the move\n          xAddIsValid = false\n        }\n      }\n    }\n\n    // If horizontal move is valid update x variable (move the tile)\n    if (xAddIsValid) {\n      x += xAdd\n    }\n\n    // Try to rotate the tile\n    let newRotate = rotate + rotateAdd > 3 ? 0 : rotate + rotateAdd\n    let rotateIsValid = true\n\n    // Test if tile should rotate\n    if (rotateAdd !== 0) {\n      for (let i = 0; i <= 3; i++) {\n        // Test if tile can be rotated without getting outside the board\n        if (\n          x + tiles[tile][newRotate][i][0] >= 0 &&\n          x + tiles[tile][newRotate][i][0] < this.props.boardWidth &&\n          y + tiles[tile][newRotate][i][1] >= 0 &&\n          y + tiles[tile][newRotate][i][1] < this.props.boardHeight\n        ) {\n          // Test of tile rotation is not blocked by other tiles\n          if (\n            field[y + tiles[tile][newRotate][i][1]][\n              x + tiles[tile][newRotate][i][0]\n            ] !== 0\n          ) {\n            // Prevent rotation\n            rotateIsValid = false\n          }\n        } else {\n          // Prevent rotation\n          rotateIsValid = false\n        }\n      }\n    }\n\n    // If rotation is valid update rotate variable (rotate the tile)\n    if (rotateIsValid) {\n      rotate = newRotate\n    }\n\n    // Try to speed up the fall of the tile\n    let yAddIsValid = true\n\n    // Test if tile should fall faster\n    if (yAdd !== 0) {\n      for (let i = 0; i <= 3; i++) {\n        // Test if tile can fall faster without getting outside the board\n        if (\n          y + yAdd + tiles[tile][rotate][i][1] >= 0 &&\n          y + yAdd + tiles[tile][rotate][i][1] < this.props.boardHeight\n        ) {\n          // Test if faster fall is not blocked by other tiles\n          if (\n            field[y + yAdd + tiles[tile][rotate][i][1]][\n              x + tiles[tile][rotate][i][0]\n            ] !== 0\n          ) {\n            // Prevent faster fall\n            yAddIsValid = false\n          }\n        } else {\n          // Prevent faster fall\n          yAddIsValid = false\n        }\n      }\n    }\n\n    // If speeding up the fall is valid (move the tile down faster)\n    if (yAddIsValid) {\n      y += yAdd\n    }\n\n    // Render the tile at new position\n    field[y + tiles[tile][rotate][0][1]][x + tiles[tile][rotate][0][0]] = tile\n    field[y + tiles[tile][rotate][1][1]][x + tiles[tile][rotate][1][0]] = tile\n    field[y + tiles[tile][rotate][2][1]][x + tiles[tile][rotate][2][0]] = tile\n    field[y + tiles[tile][rotate][3][1]][x + tiles[tile][rotate][3][0]] = tile\n\n    // If moving down is not possible, remove completed rows add score\n    // and find next tile and check if game is over\n    if (!yAddIsValid) {\n      for (let row = this.props.boardHeight - 1; row >= 0; row--) {\n        let isLineComplete = true\n\n        // Check if row is completed\n        for (let col = 0; col < this.props.boardWidth; col++) {\n          if (field[row][col] === 0) {\n            isLineComplete = false\n          }\n        }\n\n        // Remove completed rows\n        if (isLineComplete) {\n          for (let yRowSrc = row; row > 0; row--) {\n            for (let col = 0; col < this.props.boardWidth; col++) {\n              field[row][col] = field[row - 1][col]\n            }\n          }\n\n          // Check if the row is the last\n          row = this.props.boardHeight\n        }\n      }\n\n      // Update state - update score, update number of tiles, change level\n      this.setState(prev => ({\n        score: prev.score + 1 * prev.level,\n        tileCount: prev.tileCount + 1,\n        level: 1 + Math.floor(prev.tileCount / 10)\n      }))\n\n      // Prepare new timer\n      let timerId\n\n      // Reset the timer\n      clearInterval(this.state.timerId)\n\n      // Update new timer\n      timerId = setInterval(\n        () => this.handleBoardUpdate('down'),\n        1000 - (this.state.level * 10 > 600 ? 600 : this.state.level * 10)\n      )\n\n      // Use new timer\n      this.setState({\n        timerId: timerId\n      })\n\n      // Create new tile\n      tile = Math.floor(Math.random() * 7 + 1)\n      x = parseInt(this.props.boardWidth) / 2\n      y = 1\n      rotate = 0\n\n      // Test if game is over - test if new tile can't be placed in field\n      if (\n        field[y + tiles[tile][rotate][0][1]][x + tiles[tile][rotate][0][0]] !== 0 ||\n        field[y + tiles[tile][rotate][1][1]][x + tiles[tile][rotate][1][0]] !== 0 ||\n        field[y + tiles[tile][rotate][2][1]][x + tiles[tile][rotate][2][0]] !== 0 ||\n        field[y + tiles[tile][rotate][3][1]][x + tiles[tile][rotate][3][0]] !== 0\n      ) {\n        // Stop the game\n        this.setState({\n          gameOver: true\n        })\n      } else {\n        // Otherwise, render new tile and continue\n        field[y + tiles[tile][rotate][0][1]][x + tiles[tile][rotate][0][0]] = tile\n        field[y + tiles[tile][rotate][1][1]][x + tiles[tile][rotate][1][0]] = tile\n        field[y + tiles[tile][rotate][2][1]][x + tiles[tile][rotate][2][0]] = tile\n        field[y + tiles[tile][rotate][3][1]][x + tiles[tile][rotate][3][0]] = tile\n      }\n    }\n\n    // Update state - use new field, active x/y coordinates, rotation and activeTile\n    this.setState({\n      field: field,\n      activeTileX: x,\n      activeTileY: y,\n      tileRotate: rotate,\n      activeTile: tile\n    })\n  }\n\n  /**\n   * @description Stops and resumes the game\n   * @memberof Tetris\n   */\n  handlePauseClick = () => {\n    this.setState(prev => ({\n      isPaused: !prev.isPaused\n    }))\n  }\n\n  /**\n   * @description Resets the game\n   * @memberof Tetris\n   */\n  handleNewGameClick = () => {\n    // Create an empty board\n    let field: any[] = []\n\n    for (let y = 0; y < this.props.boardHeight; y++) {\n      let row = []\n\n      for (let x = 0; x < this.props.boardWidth; x++) {\n        row.push(0)\n      }\n\n      field.push(row)\n    }\n\n    // Set starting column to center\n    let xStart = Math.floor(parseInt(this.props.boardWidth) / 2)\n\n    // Initialize state with starting conditions\n    this.setState({\n      activeTileX: xStart,\n      activeTileY: 1,\n      activeTile: 2,\n      tileRotate: 0,\n      score: 0,\n      level: 1,\n      tileCount: 0,\n      gameOver: false,\n      field: field\n    })\n  }\n\n  render() {\n    return (\n      <div className=\"tetris\">\n\n        <TetrisBoard\n          field={this.state.field}\n          gameOver={this.state.gameOver}\n          score={this.state.score}\n          level={this.state.level}\n          rotate={this.state.tileRotate}\n        />\n\n        {/* Buttons to control blocks */}\n        <div className='tetris__block-controls'>\n          <button className=\"btn\" onClick={() => this.handleBoardUpdate('left')}>Left</button>\n\n          <button className=\"btn\" onClick={() => this.handleBoardUpdate('down')}>Down</button>\n\n          <button className=\"btn\" onClick={() => this.handleBoardUpdate('right')}>Right</button>\n\n          <button className=\"btn\" onClick={() => this.handleBoardUpdate('rotate')}>Rotate</button>\n        </div>\n\n        {/* Buttons to control game */}\n        <div className=\"tetris__game-controls\">\n          <button className=\"btn\" onClick={this.handleNewGameClick}>New Game</button>\n\n          <button className=\"btn\" onClick={this.handlePauseClick}>{this.state.isPaused ? 'Resume' : 'Pause'}</button>\n        </div>\n      </div>\n    )\n  }\n}\n\nexport default Tetris\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import * as React from 'react'\nimport * as ReactDOM from 'react-dom'\n\nimport Tetris from './components/tetris'\nimport './styles/styles.css'\n\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(<Tetris boardWidth=\"14\" boardHeight=\"20\" />, document.getElementById('root'))\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}